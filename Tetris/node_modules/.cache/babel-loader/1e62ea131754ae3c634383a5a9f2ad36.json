{"ast":null,"code":"import { defaultCell } from \"./Cell\";\nimport { movePlayer } from \"./PlayerController\";\nimport { transferToBoard } from \"/business/Tetrominoes\";\nexport const buildBoard = _ref => {\n  let {\n    rows,\n    columns\n  } = _ref;\n  const builtRows = Array.from({\n    length: rows\n  }, () => Array.from({\n    length: columns\n  }, () => ({\n    ...defaultCell\n  })));\n  return {\n    rows: builtRows,\n    size: {\n      rows,\n      columns\n    }\n  };\n};\nconst findDropPosition = _ref2 => {\n  let {\n    board,\n    position,\n    shape\n  } = _ref2;\n  let max = board.size.rows - position.row + 1;\n  let row = 0;\n  for (let i = 0; i < max; i++) {\n    const delta = {\n      row: i,\n      column: 0\n    };\n    const result = movePlayer({\n      delta,\n      position,\n      shape,\n      board\n    });\n    const {\n      collided\n    } = result;\n    if (collided) {\n      break;\n    }\n    row = position.row + i;\n  }\n  return {\n    ...position,\n    row\n  };\n};\nexport const nextBoard = _ref3 => {\n  let {\n    board,\n    player,\n    resetPlayer,\n    addLinesCleared\n  } = _ref3;\n  const {\n    tetromino,\n    position\n  } = player;\n\n  // Copy and clear spaces used by pieces that\n  // hadn't collided and occupied spaces permanently\n  let rows = board.rows.map(row => row.map(cell => cell.occupied ? cell : {\n    ...defaultCell\n  }));\n\n  // Drop position\n  const dropPosition = findDropPosition({\n    board,\n    position,\n    shape: tetromino.shape\n  });\n\n  // Place ghost\n  const className = `${tetromino.className} ${player.isFastDropping ? \"\" : \"ghost\"}`;\n  rows = transferToBoard({\n    className,\n    isOccupied: player.isFastDropping,\n    position: dropPosition,\n    rows,\n    shape: tetromino.shape\n  });\n\n  // Place the piece.\n  // If it collided, mark the board cells as collided\n  if (!player.isFastDropping) {\n    rows = transferToBoard({\n      className: tetromino.className,\n      isOccupied: player.collided,\n      position,\n      rows,\n      shape: tetromino.shape\n    });\n  }\n\n  // Check for cleared lines\n  const blankRow = rows[0].map(_ => ({\n    ...defaultCell\n  }));\n  let linesCleared = 0;\n  rows = rows.reduce((acc, row) => {\n    if (row.every(column => column.occupied)) {\n      linesCleared++;\n      acc.unshift([...blankRow]);\n    } else {\n      acc.push(row);\n    }\n    return acc;\n  }, []);\n  if (linesCleared > 0) {\n    addLinesCleared(linesCleared);\n  }\n\n  // If we collided, reset the player!\n  if (player.collided || player.isFastDropping) {\n    resetPlayer();\n  }\n\n  // Return the next board\n  return {\n    rows,\n    size: {\n      ...board.size\n    }\n  };\n};\nexport const hasCollision = _ref4 => {\n  let {\n    board,\n    position,\n    shape\n  } = _ref4;\n  for (let y = 0; y < shape.length; y++) {\n    const row = y + position.row;\n    for (let x = 0; x < shape[y].length; x++) {\n      if (shape[y][x]) {\n        const column = x + position.column;\n        if (board.rows[row] && board.rows[row][column] && board.rows[row][column].occupied) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\nexport const isWithinBoard = _ref5 => {\n  let {\n    board,\n    position,\n    shape\n  } = _ref5;\n  for (let y = 0; y < shape.length; y++) {\n    const row = y + position.row;\n    for (let x = 0; x < shape[y].length; x++) {\n      if (shape[y][x]) {\n        const column = x + position.column;\n        const isValidPosition = board.rows[row] && board.rows[row][column];\n        if (!isValidPosition) return false;\n      }\n    }\n  }\n  return true;\n};","map":{"version":3,"names":["defaultCell","movePlayer","transferToBoard","buildBoard","rows","columns","builtRows","Array","from","length","size","findDropPosition","board","position","shape","max","row","i","delta","column","result","collided","nextBoard","player","resetPlayer","addLinesCleared","tetromino","map","cell","occupied","dropPosition","className","isFastDropping","isOccupied","blankRow","_","linesCleared","reduce","acc","every","unshift","push","hasCollision","y","x","isWithinBoard","isValidPosition"],"sources":["C:/Sachin's folder/Programming/HTML/React/reactjs/src/business/Board.js"],"sourcesContent":["import { defaultCell } from \"./Cell\";\r\nimport { movePlayer } from \"./PlayerController\";\r\nimport { transferToBoard } from \"/business/Tetrominoes\";\r\n\r\nexport const buildBoard = ({ rows, columns }) => {\r\n  const builtRows = Array.from({ length: rows }, () =>\r\n    Array.from({ length: columns }, () => ({ ...defaultCell }))\r\n  );\r\n\r\n  return {\r\n    rows: builtRows,\r\n    size: { rows, columns }\r\n  };\r\n};\r\n\r\nconst findDropPosition = ({ board, position, shape }) => {\r\n  let max = board.size.rows - position.row + 1;\r\n  let row = 0;\r\n\r\n  for (let i = 0; i < max; i++) {\r\n    const delta = { row: i, column: 0 };\r\n    const result = movePlayer({ delta, position, shape, board });\r\n    const { collided } = result;\r\n\r\n    if (collided) {\r\n      break;\r\n    }\r\n\r\n    row = position.row + i;\r\n  }\r\n\r\n  return { ...position, row };\r\n};\r\n\r\nexport const nextBoard = ({ board, player, resetPlayer, addLinesCleared }) => {\r\n  const { tetromino, position } = player;\r\n\r\n  // Copy and clear spaces used by pieces that\r\n  // hadn't collided and occupied spaces permanently\r\n  let rows = board.rows.map((row) =>\r\n    row.map((cell) => (cell.occupied ? cell : { ...defaultCell }))\r\n  );\r\n\r\n  // Drop position\r\n  const dropPosition = findDropPosition({\r\n    board,\r\n    position,\r\n    shape: tetromino.shape\r\n  });\r\n\r\n  // Place ghost\r\n  const className = `${tetromino.className} ${\r\n    player.isFastDropping ? \"\" : \"ghost\"\r\n  }`;\r\n  rows = transferToBoard({\r\n    className,\r\n    isOccupied: player.isFastDropping,\r\n    position: dropPosition,\r\n    rows,\r\n    shape: tetromino.shape\r\n  });\r\n\r\n  // Place the piece.\r\n  // If it collided, mark the board cells as collided\r\n  if (!player.isFastDropping) {\r\n    rows = transferToBoard({\r\n      className: tetromino.className,\r\n      isOccupied: player.collided,\r\n      position,\r\n      rows,\r\n      shape: tetromino.shape\r\n    });\r\n  }\r\n\r\n  // Check for cleared lines\r\n  const blankRow = rows[0].map((_) => ({ ...defaultCell }));\r\n  let linesCleared = 0;\r\n  rows = rows.reduce((acc, row) => {\r\n    if (row.every((column) => column.occupied)) {\r\n      linesCleared++;\r\n      acc.unshift([...blankRow]);\r\n    } else {\r\n      acc.push(row);\r\n    }\r\n\r\n    return acc;\r\n  }, []);\r\n\r\n  if (linesCleared > 0) {\r\n    addLinesCleared(linesCleared);\r\n  }\r\n\r\n  // If we collided, reset the player!\r\n  if (player.collided || player.isFastDropping) {\r\n    resetPlayer();\r\n  }\r\n\r\n  // Return the next board\r\n  return {\r\n    rows,\r\n    size: { ...board.size }\r\n  };\r\n};\r\n\r\nexport const hasCollision = ({ board, position, shape }) => {\r\n  for (let y = 0; y < shape.length; y++) {\r\n    const row = y + position.row;\r\n\r\n    for (let x = 0; x < shape[y].length; x++) {\r\n      if (shape[y][x]) {\r\n        const column = x + position.column;\r\n\r\n        if (\r\n          board.rows[row] &&\r\n          board.rows[row][column] &&\r\n          board.rows[row][column].occupied\r\n        ) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nexport const isWithinBoard = ({ board, position, shape }) => {\r\n  for (let y = 0; y < shape.length; y++) {\r\n    const row = y + position.row;\r\n\r\n    for (let x = 0; x < shape[y].length; x++) {\r\n      if (shape[y][x]) {\r\n        const column = x + position.column;\r\n        const isValidPosition = board.rows[row] && board.rows[row][column];\r\n\r\n        if (!isValidPosition) return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}